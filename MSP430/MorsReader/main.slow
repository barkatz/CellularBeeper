#include <msp430.h>
#include "misc.h"
#include "utils.h"
#include "uart.h"
  
#define LED_PIN     BIT5
#define UNIT_TIME   0x70 

#define DOT         1
#define DASH        0
#define IGNORE      2

static char chars_to_units[26][5] = {
  {DOT ,  DASH,   IGNORE, IGNORE, IGNORE },    /* A */
  {DASH,  DOT,    DOT,    DOT,    IGNORE },    /* B */
  {DASH,  DOT,    DASH,   DOT,    IGNORE },    /* C */
  {DASH,  DOT,    DOT,    IGNORE, IGNORE },    /* D */
  {DOT,   IGNORE, IGNORE, IGNORE, IGNORE },    /* E */
  {DOT,   DOT,    DASH,   DOT,    IGNORE },    /* F */
  {DASH,  DASH,   DOT,    IGNORE, IGNORE },    /* G */
  {DOT,   DOT,    DOT,    DOT,    IGNORE },    /* H */
  {DOT,   DOT,    IGNORE, IGNORE, IGNORE },    /* I */
  {DOT,   DASH,   DASH,   DASH,   IGNORE },    /* J */
  {DASH,  DOT,    DASH,   IGNORE, IGNORE },    /* K */
  {DOT,   DASH,   DOT,    DOT,    IGNORE },    /* L */
  {DASH,  DASH,   IGNORE, IGNORE, IGNORE },    /* M */
  {DASH,  DOT,    IGNORE, IGNORE, IGNORE },    /* N */
  {DASH,  DASH,   DASH,   IGNORE, IGNORE },    /* O */
  {DOT,   DASH,   DASH,   DOT,    IGNORE },    /* P */
  {DASH,  DASH,   DOT,    DASH,   IGNORE },    /* Q */
  {DOT,   DASH,   DOT,    IGNORE, IGNORE },    /* R */
  {DOT,   DOT,    DOT,    IGNORE, IGNORE },    /* S */
  {DASH,  IGNORE, IGNORE, IGNORE, IGNORE },    /* T */
  {DOT,   DOT,    DASH,   IGNORE, IGNORE },    /* U */
  {DOT,   DOT,    DOT,    DASH,   IGNORE },    /* V */
  {DOT,   DASH,   DASH,   IGNORE, IGNORE },    /* W */
  {DASH,  DOT,    DOT,    DASH,   IGNORE },    /* X */
  {DOT,   DOT,    DOT,    DASH,   IGNORE },    /* Y */
  {DASH,  DASH,   DOT,    DOT,    IGNORE },    /* Z */

};

//
// Need to use ACLK, but in the meanwhile we will slow it down using software.
//
#define SLOW_RATIO 0x70
static int slow_counter_low = 0;
static int slow_counter_high = 0;
static int my_taccr0 = 0;


static int counter = 0;
static int last_counter = 0;


static int index_in_msg = 0;
static int index_in_char = 0;
static char space_between_symbols = 0;
static char msg[] = "sos ";
static char cur_char;

/*
A simple timer example which toggels pinX every second.
*/
int main() {
  WDTCTL = WDTPW | WDTHOLD;                 // stop WDT

  // configure main clock
  BCSCTL1 = CALBC1_1MHZ;                    // set DCO to 1MHz
  DCOCTL  = CALDCO_1MHZ;
  
  // Define the LED_PIN as output.
  P1DIR &= ~LED_PIN;  
  P1DIR |= (BIT6  | BIT0);
  P1OUT = 0;

  TA0CCTL0 = OUTMOD_0 | CCIE;
  TA0CCR0 = 0xffff;
  my_taccr0 = UNIT_TIME;
  //TA0CTL = TASSEL_2 | ID_3 | MC_1 | TAIE; 

  P1IES |= LED_PIN; // Hi/Lo edge
  P1IE |= LED_PIN; // Enable interrupt
  P1IFG &= ~LED_PIN;

  // uart_init(UART_SRC_SMCLK, 104, UCBRS0);
  // uart_puts("Initializing morse reader.\n");


  // enter LPM0, interrupts enabled
  __bis_SR_register(LPM0_bits + GIE);       
  //while (1) {}
  
}


#define EPSILON 2




#define N_DASH          3
#define N_DOT           1
#define N_SPACE         7
#define N_LETTER_SPACE  3


#define RATIO            2
#define CHECK_RATIO(diff, type) (((diff) > ((type)*RATIO - EPSILON)) && ((diff) < ((type)*RATIO + EPSILON)))


#define DASH_LOW_THRESHOLD     (DASH*RATIO - EPSILON)
#define DASH_HIGH_THRESHOLD    (DASH*RATIO + EPSILON)


#define WAS_LED_ON            (P1IES & LED_PIN)

#pragma vector=PORT1_VECTOR
__interrupt void Port1_ISR(void)
{
  // // Start timer...
  // if (!(TA0CTL & TAIE)) {
  //   //uart_puts("IN HERE?");
  //   TA0CCTL0 = CCIE;
  //   //TA0CCR0 = UNIT_TIME / RATIO;
  //   // Start Timer A using src clk in continuous mode
  //   TA0CTL = TASSEL_2 | ID_3 | MC_1 | TAIE; 
  // }
  // uart_puts("AA");
  // buttonsPressed = P2IFG;
  // slow_counter_low * 0xffff + TAR
  P1IFG &= ~LED_PIN; // Clear the flag telling us where we came from
  P1IES ^= LED_PIN;  // Toggle the high/low bit


  // // calculate time difference

  // int diff = counter - last_counter;

  // uart_putc('0' + diff);
  // if (WAS_LED_ON) {
  //   if (CHECK_RATIO(diff, N_DASH)) {
  //     uart_puts("dash\n");
  //   } else if (CHECK_RATIO(diff, N_DOT)){
  //      uart_puts("dot\n");
  //   } else {
  //     uart_puts("error1\n");
  //   }
  // } else {// led was off
  //   if (CHECK_RATIO(diff, N_SPACE)) {
  //     uart_puts("space\n");
  //   } else if(CHECK_RATIO(diff, N_LETTER_SPACE)) {
  //     uart_puts("letter space\n");
  //   } else {
  //     uart_puts("error2\n");
  //  }
  // }


  // last_counter = counter;

  P1OUT ^= BIT6;     // Internal LED.
  return; 
}

int do_slow_clock() {
  P1OUT |= BIT0;
  counter++;
}


#pragma vector=TIMER0_A0_VECTOR
__interrupt void timer_interrupt() {
  TA0CCR0 = 0xffff;
  return;
  // slow_counter_low++;
  // if (slow_counter_low == UNIT_TIME) {
  //   slow_counter_low = 0;
  //   do_slow_clock();
  // } 

  // // NOTE: / 2
  // TA0CCR0 = UNIT_TIME / RATIO;
}

